"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-currency-input-field";
exports.ids = ["vendor-chunks/react-currency-input-field"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-currency-input-field/dist/index.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-currency-input-field/dist/index.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanValue: () => (/* binding */ cleanValue),\n/* harmony export */   \"default\": () => (/* binding */ CurrencyInput),\n/* harmony export */   formatValue: () => (/* binding */ formatValue)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n\nvar __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  };\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\n/**\n * Escape regex char\n *\n * See: https://stackoverflow.com/questions/17885855/use-dynamic-variable-string-as-regex-pattern-in-javascript\n */\nvar escapeRegExp = function (stringToGoIntoTheRegex) {\n    return stringToGoIntoTheRegex.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n};\n\nvar abbrMap = { k: 1000, m: 1000000, b: 1000000000 };\n/**\n * Parse a value with abbreviation e.g 1k = 1000\n */\nvar parseAbbrValue = function (value, decimalSeparator) {\n    if (decimalSeparator === void 0) { decimalSeparator = '.'; }\n    var reg = new RegExp(\"(\\\\d+(\".concat(escapeRegExp(decimalSeparator), \"\\\\d*)?)([kmb])$\"), 'i');\n    var match = value.match(reg);\n    if (match) {\n        var digits = match[1], abbr = match[3];\n        var multiplier = abbrMap[abbr.toLowerCase()];\n        return Number(digits.replace(decimalSeparator, '.')) * multiplier;\n    }\n    return undefined;\n};\n\n/**\n * Remove group separator from value eg. 1,000 > 1000\n */\nvar removeSeparators = function (value, separator) {\n    if (separator === void 0) { separator = ','; }\n    var reg = new RegExp(escapeRegExp(separator), 'g');\n    return value.replace(reg, '');\n};\n\n/**\n * Remove invalid characters\n */\nvar removeInvalidChars = function (value, validChars) {\n    var chars = escapeRegExp(validChars.join(''));\n    var reg = new RegExp(\"[^\\\\d\".concat(chars, \"]\"), 'gi');\n    return value.replace(reg, '');\n};\n\n/**\n * Remove prefix, separators and extra decimals from value\n */\nvar cleanValue = function (_a) {\n    var value = _a.value, _b = _a.groupSeparator, groupSeparator = _b === void 0 ? ',' : _b, _c = _a.decimalSeparator, decimalSeparator = _c === void 0 ? '.' : _c, _d = _a.allowDecimals, allowDecimals = _d === void 0 ? true : _d, _e = _a.decimalsLimit, decimalsLimit = _e === void 0 ? 2 : _e, _f = _a.allowNegativeValue, allowNegativeValue = _f === void 0 ? true : _f, _g = _a.disableAbbreviations, disableAbbreviations = _g === void 0 ? false : _g, _h = _a.prefix, prefix = _h === void 0 ? '' : _h, _j = _a.transformRawValue, transformRawValue = _j === void 0 ? function (rawValue) { return rawValue; } : _j;\n    var transformedValue = transformRawValue(value);\n    if (transformedValue === '-') {\n        return transformedValue;\n    }\n    var abbreviations = disableAbbreviations ? [] : ['k', 'm', 'b'];\n    var reg = new RegExp(\"((^|\\\\D)-\\\\d)|(-\".concat(escapeRegExp(prefix), \")\"));\n    var isNegative = reg.test(transformedValue);\n    // Is there a digit before the prefix? eg. 1$\n    var _k = RegExp(\"(\\\\d+)-?\".concat(escapeRegExp(prefix))).exec(value) || [], prefixWithValue = _k[0], preValue = _k[1];\n    var withoutPrefix = prefix\n        ? prefixWithValue\n            ? transformedValue.replace(prefixWithValue, '').concat(preValue)\n            : transformedValue.replace(prefix, '')\n        : transformedValue;\n    var withoutSeparators = removeSeparators(withoutPrefix, groupSeparator);\n    var withoutInvalidChars = removeInvalidChars(withoutSeparators, __spreadArray([\n        groupSeparator,\n        decimalSeparator\n    ], abbreviations, true));\n    var valueOnly = withoutInvalidChars;\n    if (!disableAbbreviations) {\n        // disallow letter without number\n        if (abbreviations.some(function (letter) { return letter === withoutInvalidChars.toLowerCase().replace(decimalSeparator, ''); })) {\n            return '';\n        }\n        var parsed = parseAbbrValue(withoutInvalidChars, decimalSeparator);\n        if (parsed) {\n            valueOnly = String(parsed);\n        }\n    }\n    var includeNegative = isNegative && allowNegativeValue ? '-' : '';\n    if (decimalSeparator && valueOnly.includes(decimalSeparator)) {\n        var _l = withoutInvalidChars.split(decimalSeparator), int = _l[0], decimals = _l[1];\n        var trimmedDecimals = decimalsLimit && decimals ? decimals.slice(0, decimalsLimit) : decimals;\n        var includeDecimals = allowDecimals ? \"\".concat(decimalSeparator).concat(trimmedDecimals) : '';\n        return \"\".concat(includeNegative).concat(int).concat(includeDecimals);\n    }\n    return \"\".concat(includeNegative).concat(valueOnly);\n};\n\nvar fixedDecimalValue = function (value, decimalSeparator, fixedDecimalLength) {\n    if (fixedDecimalLength !== undefined && value.length > 1) {\n        if (fixedDecimalLength === 0) {\n            return value.replace(decimalSeparator, '');\n        }\n        if (value.includes(decimalSeparator)) {\n            var _a = value.split(decimalSeparator), int = _a[0], decimals = _a[1];\n            if (decimals.length === fixedDecimalLength) {\n                return value;\n            }\n            if (decimals.length > fixedDecimalLength) {\n                return \"\".concat(int).concat(decimalSeparator).concat(decimals.slice(0, fixedDecimalLength));\n            }\n        }\n        var reg = value.length > fixedDecimalLength\n            ? new RegExp(\"(\\\\d+)(\\\\d{\".concat(fixedDecimalLength, \"})\"))\n            : new RegExp(\"(\\\\d)(\\\\d+)\");\n        var match = value.match(reg);\n        if (match) {\n            var int = match[1], decimals = match[2];\n            return \"\".concat(int).concat(decimalSeparator).concat(decimals);\n        }\n    }\n    return value;\n};\n\nvar getSuffix = function (value, _a) {\n    var _b = _a.groupSeparator, groupSeparator = _b === void 0 ? ',' : _b, _c = _a.decimalSeparator, decimalSeparator = _c === void 0 ? '.' : _c;\n    var suffixReg = new RegExp(\"\\\\d([^\".concat(escapeRegExp(groupSeparator)).concat(escapeRegExp(decimalSeparator), \"0-9]+)\"));\n    var suffixMatch = value.match(suffixReg);\n    return suffixMatch ? suffixMatch[1] : undefined;\n};\n\n/**\n * Format value with decimal separator, group separator and prefix\n */\nvar formatValue = function (options) {\n    var _value = options.value, decimalSeparator = options.decimalSeparator, intlConfig = options.intlConfig, decimalScale = options.decimalScale, _a = options.prefix, prefix = _a === void 0 ? '' : _a, _b = options.suffix, suffix = _b === void 0 ? '' : _b;\n    if (_value === '' || _value === undefined) {\n        return '';\n    }\n    if (_value === '-') {\n        return '-';\n    }\n    var isNegative = new RegExp(\"^\\\\d?-\".concat(prefix ? \"\".concat(escapeRegExp(prefix), \"?\") : '', \"\\\\d\")).test(_value);\n    var value = decimalSeparator !== '.'\n        ? replaceDecimalSeparator(_value, decimalSeparator, isNegative)\n        : _value;\n    if (decimalSeparator && decimalSeparator !== '-' && value.startsWith(decimalSeparator)) {\n        value = '0' + value;\n    }\n    var defaultNumberFormatOptions = {\n        minimumFractionDigits: decimalScale || 0,\n        maximumFractionDigits: 20,\n    };\n    var numberFormatter = intlConfig\n        ? new Intl.NumberFormat(intlConfig.locale, intlConfig.currency\n            ? __assign(__assign({}, defaultNumberFormatOptions), { style: 'currency', currency: intlConfig.currency }) : defaultNumberFormatOptions)\n        : new Intl.NumberFormat(undefined, defaultNumberFormatOptions);\n    var parts = numberFormatter.formatToParts(Number(value));\n    var formatted = replaceParts(parts, options);\n    // Does intl formatting add a suffix?\n    var intlSuffix = getSuffix(formatted, __assign({}, options));\n    // Include decimal separator if user input ends with decimal separator\n    var includeDecimalSeparator = _value.slice(-1) === decimalSeparator ? decimalSeparator : '';\n    var _c = value.match(RegExp('\\\\d+\\\\.(\\\\d+)')) || [], decimals = _c[1];\n    // Keep original decimal padding if no decimalScale\n    if (decimalScale === undefined && decimals && decimalSeparator) {\n        if (formatted.includes(decimalSeparator)) {\n            formatted = formatted.replace(RegExp(\"(\\\\d+)(\".concat(escapeRegExp(decimalSeparator), \")(\\\\d+)\"), 'g'), \"$1$2\".concat(decimals));\n        }\n        else {\n            if (intlSuffix && !suffix) {\n                formatted = formatted.replace(intlSuffix, \"\".concat(decimalSeparator).concat(decimals).concat(intlSuffix));\n            }\n            else {\n                formatted = \"\".concat(formatted).concat(decimalSeparator).concat(decimals);\n            }\n        }\n    }\n    if (suffix && includeDecimalSeparator) {\n        return \"\".concat(formatted).concat(includeDecimalSeparator).concat(suffix);\n    }\n    if (intlSuffix && includeDecimalSeparator) {\n        return formatted.replace(intlSuffix, \"\".concat(includeDecimalSeparator).concat(intlSuffix));\n    }\n    if (intlSuffix && suffix) {\n        return formatted.replace(intlSuffix, \"\".concat(includeDecimalSeparator).concat(suffix));\n    }\n    return [formatted, includeDecimalSeparator, suffix].join('');\n};\n/**\n * Before converting to Number, decimal separator has to be .\n */\nvar replaceDecimalSeparator = function (value, decimalSeparator, isNegative) {\n    var newValue = value;\n    if (decimalSeparator && decimalSeparator !== '.') {\n        newValue = newValue.replace(RegExp(escapeRegExp(decimalSeparator), 'g'), '.');\n        if (isNegative && decimalSeparator === '-') {\n            newValue = \"-\".concat(newValue.slice(1));\n        }\n    }\n    return newValue;\n};\nvar replaceParts = function (parts, _a) {\n    var prefix = _a.prefix, groupSeparator = _a.groupSeparator, decimalSeparator = _a.decimalSeparator, decimalScale = _a.decimalScale, _b = _a.disableGroupSeparators, disableGroupSeparators = _b === void 0 ? false : _b;\n    return parts\n        .reduce(function (prev, _a, i) {\n        var type = _a.type, value = _a.value;\n        if (i === 0 && prefix) {\n            if (type === 'minusSign') {\n                return [value, prefix];\n            }\n            if (type === 'currency') {\n                return __spreadArray(__spreadArray([], prev, true), [prefix], false);\n            }\n            return [prefix, value];\n        }\n        if (type === 'currency') {\n            return prefix ? prev : __spreadArray(__spreadArray([], prev, true), [value], false);\n        }\n        if (type === 'group') {\n            return !disableGroupSeparators\n                ? __spreadArray(__spreadArray([], prev, true), [groupSeparator !== undefined ? groupSeparator : value], false) : prev;\n        }\n        if (type === 'decimal') {\n            if (decimalScale !== undefined && decimalScale === 0) {\n                return prev;\n            }\n            return __spreadArray(__spreadArray([], prev, true), [decimalSeparator !== undefined ? decimalSeparator : value], false);\n        }\n        if (type === 'fraction') {\n            return __spreadArray(__spreadArray([], prev, true), [decimalScale !== undefined ? value.slice(0, decimalScale) : value], false);\n        }\n        return __spreadArray(__spreadArray([], prev, true), [value], false);\n    }, [''])\n        .join('');\n};\n\nvar defaultConfig = {\n    currencySymbol: '',\n    groupSeparator: '',\n    decimalSeparator: '',\n    prefix: '',\n    suffix: '',\n};\n/**\n * Get locale config from input or default\n */\nvar getLocaleConfig = function (intlConfig) {\n    var _a = intlConfig || {}, locale = _a.locale, currency = _a.currency;\n    var numberFormatter = locale\n        ? new Intl.NumberFormat(locale, currency ? { currency: currency, style: 'currency' } : undefined)\n        : new Intl.NumberFormat();\n    return numberFormatter.formatToParts(1000.1).reduce(function (prev, curr, i) {\n        if (curr.type === 'currency') {\n            if (i === 0) {\n                return __assign(__assign({}, prev), { currencySymbol: curr.value, prefix: curr.value });\n            }\n            else {\n                return __assign(__assign({}, prev), { currencySymbol: curr.value, suffix: curr.value });\n            }\n        }\n        if (curr.type === 'group') {\n            return __assign(__assign({}, prev), { groupSeparator: curr.value });\n        }\n        if (curr.type === 'decimal') {\n            return __assign(__assign({}, prev), { decimalSeparator: curr.value });\n        }\n        return prev;\n    }, defaultConfig);\n};\n\nvar isNumber = function (input) { return RegExp(/\\d/, 'gi').test(input); };\n\nvar padTrimValue = function (value, decimalSeparator, decimalScale) {\n    if (decimalSeparator === void 0) { decimalSeparator = '.'; }\n    if (decimalScale === undefined || value === '' || value === undefined) {\n        return value;\n    }\n    if (!value.match(/\\d/g)) {\n        return '';\n    }\n    var _a = value.split(decimalSeparator), int = _a[0], decimals = _a[1];\n    if (decimalScale === 0) {\n        return int;\n    }\n    var newValue = decimals || '';\n    if (newValue.length < decimalScale) {\n        while (newValue.length < decimalScale) {\n            newValue += '0';\n        }\n    }\n    else {\n        newValue = newValue.slice(0, decimalScale);\n    }\n    return \"\".concat(int).concat(decimalSeparator).concat(newValue);\n};\n\n/**\n * Based on the last key stroke and the cursor position, update the value\n * and reposition the cursor to the right place\n */\nvar repositionCursor = function (_a) {\n    var selectionStart = _a.selectionStart, value = _a.value, lastKeyStroke = _a.lastKeyStroke, stateValue = _a.stateValue, groupSeparator = _a.groupSeparator;\n    var cursorPosition = selectionStart;\n    var modifiedValue = value;\n    if (stateValue && cursorPosition) {\n        var splitValue = value.split('');\n        // if cursor is to right of groupSeparator and backspace pressed, delete the character to the left of the separator and reposition the cursor\n        if (lastKeyStroke === 'Backspace' && stateValue[cursorPosition] === groupSeparator) {\n            splitValue.splice(cursorPosition - 1, 1);\n            cursorPosition -= 1;\n        }\n        // if cursor is to left of groupSeparator and delete pressed, delete the character to the right of the separator and reposition the cursor\n        if (lastKeyStroke === 'Delete' && stateValue[cursorPosition] === groupSeparator) {\n            splitValue.splice(cursorPosition, 1);\n            cursorPosition += 1;\n        }\n        modifiedValue = splitValue.join('');\n        return { modifiedValue: modifiedValue, cursorPosition: cursorPosition };\n    }\n    return { modifiedValue: modifiedValue, cursorPosition: selectionStart };\n};\n\nvar CurrencyInput = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_a, ref) {\n    var _b = _a.allowDecimals, allowDecimals = _b === void 0 ? true : _b, _c = _a.allowNegativeValue, allowNegativeValue = _c === void 0 ? true : _c, id = _a.id, name = _a.name, className = _a.className, customInput = _a.customInput, decimalsLimit = _a.decimalsLimit, defaultValue = _a.defaultValue, _d = _a.disabled, disabled = _d === void 0 ? false : _d, userMaxLength = _a.maxLength, userValue = _a.value, onValueChange = _a.onValueChange, fixedDecimalLength = _a.fixedDecimalLength, placeholder = _a.placeholder, decimalScale = _a.decimalScale, prefix = _a.prefix, suffix = _a.suffix, intlConfig = _a.intlConfig, step = _a.step, min = _a.min, max = _a.max, _e = _a.disableGroupSeparators, disableGroupSeparators = _e === void 0 ? false : _e, _f = _a.disableAbbreviations, disableAbbreviations = _f === void 0 ? false : _f, _decimalSeparator = _a.decimalSeparator, _groupSeparator = _a.groupSeparator, onChange = _a.onChange, onFocus = _a.onFocus, onBlur = _a.onBlur, onKeyDown = _a.onKeyDown, onKeyUp = _a.onKeyUp, transformRawValue = _a.transformRawValue, _g = _a.formatValueOnBlur, formatValueOnBlur = _g === void 0 ? true : _g, props = __rest(_a, [\"allowDecimals\", \"allowNegativeValue\", \"id\", \"name\", \"className\", \"customInput\", \"decimalsLimit\", \"defaultValue\", \"disabled\", \"maxLength\", \"value\", \"onValueChange\", \"fixedDecimalLength\", \"placeholder\", \"decimalScale\", \"prefix\", \"suffix\", \"intlConfig\", \"step\", \"min\", \"max\", \"disableGroupSeparators\", \"disableAbbreviations\", \"decimalSeparator\", \"groupSeparator\", \"onChange\", \"onFocus\", \"onBlur\", \"onKeyDown\", \"onKeyUp\", \"transformRawValue\", \"formatValueOnBlur\"]);\n    if (_decimalSeparator && isNumber(_decimalSeparator)) {\n        throw new Error('decimalSeparator cannot be a number');\n    }\n    if (_groupSeparator && isNumber(_groupSeparator)) {\n        throw new Error('groupSeparator cannot be a number');\n    }\n    var localeConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () { return getLocaleConfig(intlConfig); }, [intlConfig]);\n    var decimalSeparator = _decimalSeparator || localeConfig.decimalSeparator || '';\n    var groupSeparator = _groupSeparator || localeConfig.groupSeparator || '';\n    if (decimalSeparator &&\n        groupSeparator &&\n        decimalSeparator === groupSeparator &&\n        disableGroupSeparators === false) {\n        throw new Error('decimalSeparator cannot be the same as groupSeparator');\n    }\n    var formatValueOptions = {\n        decimalSeparator: decimalSeparator,\n        groupSeparator: groupSeparator,\n        disableGroupSeparators: disableGroupSeparators,\n        intlConfig: intlConfig,\n        prefix: prefix || localeConfig.prefix,\n        suffix: suffix,\n    };\n    var cleanValueOptions = {\n        decimalSeparator: decimalSeparator,\n        groupSeparator: groupSeparator,\n        allowDecimals: allowDecimals,\n        decimalsLimit: decimalsLimit || fixedDecimalLength || 2,\n        allowNegativeValue: allowNegativeValue,\n        disableAbbreviations: disableAbbreviations,\n        prefix: prefix || localeConfig.prefix,\n        transformRawValue: transformRawValue,\n    };\n    var _h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () {\n        return defaultValue != null\n            ? formatValue(__assign(__assign({}, formatValueOptions), { decimalScale: decimalScale, value: String(defaultValue) }))\n            : userValue != null\n                ? formatValue(__assign(__assign({}, formatValueOptions), { decimalScale: decimalScale, value: String(userValue) }))\n                : '';\n    }), stateValue = _h[0], setStateValue = _h[1];\n    var _j = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), dirty = _j[0], setDirty = _j[1];\n    var _k = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), cursor = _k[0], setCursor = _k[1];\n    var _l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), changeCount = _l[0], setChangeCount = _l[1];\n    var _m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), lastKeyStroke = _m[0], setLastKeyStroke = _m[1];\n    var inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function () { return inputRef.current; });\n    /**\n     * Process change in value\n     */\n    var processChange = function (value, selectionStart) {\n        setDirty(true);\n        var _a = repositionCursor({\n            selectionStart: selectionStart,\n            value: value,\n            lastKeyStroke: lastKeyStroke,\n            stateValue: stateValue,\n            groupSeparator: groupSeparator,\n        }), modifiedValue = _a.modifiedValue, cursorPosition = _a.cursorPosition;\n        var stringValue = cleanValue(__assign({ value: modifiedValue }, cleanValueOptions));\n        if (userMaxLength && stringValue.replace(/-/g, '').length > userMaxLength) {\n            return;\n        }\n        if (stringValue === '' || stringValue === '-' || stringValue === decimalSeparator) {\n            onValueChange && onValueChange(undefined, name, { float: null, formatted: '', value: '' });\n            setStateValue(stringValue);\n            // Always sets cursor after '-' or decimalSeparator input\n            setCursor(1);\n            return;\n        }\n        var stringValueWithoutSeparator = decimalSeparator\n            ? stringValue.replace(decimalSeparator, '.')\n            : stringValue;\n        var numberValue = parseFloat(stringValueWithoutSeparator);\n        var formattedValue = formatValue(__assign({ value: stringValue }, formatValueOptions));\n        if (cursorPosition != null) {\n            // Prevent cursor jumping\n            var newCursor = cursorPosition + (formattedValue.length - value.length);\n            newCursor = newCursor <= 0 ? (prefix ? prefix.length : 0) : newCursor;\n            setCursor(newCursor);\n            setChangeCount(changeCount + 1);\n        }\n        setStateValue(formattedValue);\n        if (onValueChange) {\n            var values = {\n                float: numberValue,\n                formatted: formattedValue,\n                value: stringValue,\n            };\n            onValueChange(stringValue, name, values);\n        }\n    };\n    /**\n     * Handle change event\n     */\n    var handleOnChange = function (event) {\n        var _a = event.target, value = _a.value, selectionStart = _a.selectionStart;\n        processChange(value, selectionStart);\n        onChange && onChange(event);\n    };\n    /**\n     * Handle focus event\n     */\n    var handleOnFocus = function (event) {\n        onFocus && onFocus(event);\n        return stateValue ? stateValue.length : 0;\n    };\n    /**\n     * Handle blur event\n     *\n     * Format value by padding/trimming decimals if required by\n     */\n    var handleOnBlur = function (event) {\n        var value = event.target.value;\n        var valueOnly = cleanValue(__assign({ value: value }, cleanValueOptions));\n        if (valueOnly === '-' || valueOnly === decimalSeparator || !valueOnly) {\n            setStateValue('');\n            onBlur && onBlur(event);\n            return;\n        }\n        var fixedDecimals = fixedDecimalValue(valueOnly, decimalSeparator, fixedDecimalLength);\n        var newValue = padTrimValue(fixedDecimals, decimalSeparator, decimalScale !== undefined ? decimalScale : fixedDecimalLength);\n        var numberValue = parseFloat(newValue.replace(decimalSeparator, '.'));\n        var formattedValue = formatValue(__assign(__assign({}, formatValueOptions), { value: newValue }));\n        if (onValueChange && formatValueOnBlur) {\n            onValueChange(newValue, name, {\n                float: numberValue,\n                formatted: formattedValue,\n                value: newValue,\n            });\n        }\n        setStateValue(formattedValue);\n        onBlur && onBlur(event);\n    };\n    /**\n     * Handle key down event\n     *\n     * Increase or decrease value by step\n     */\n    var handleOnKeyDown = function (event) {\n        var key = event.key;\n        setLastKeyStroke(key);\n        if (step && (key === 'ArrowUp' || key === 'ArrowDown')) {\n            event.preventDefault();\n            setCursor(stateValue.length);\n            var currentValue = parseFloat(userValue != null\n                ? String(userValue).replace(decimalSeparator, '.')\n                : cleanValue(__assign({ value: stateValue }, cleanValueOptions))) || 0;\n            var newValue = key === 'ArrowUp' ? currentValue + step : currentValue - step;\n            if (min !== undefined && newValue < Number(min)) {\n                return;\n            }\n            if (max !== undefined && newValue > Number(max)) {\n                return;\n            }\n            var fixedLength = String(step).includes('.')\n                ? Number(String(step).split('.')[1].length)\n                : undefined;\n            processChange(String(fixedLength ? newValue.toFixed(fixedLength) : newValue).replace('.', decimalSeparator));\n        }\n        onKeyDown && onKeyDown(event);\n    };\n    /**\n     * Handle key up event\n     *\n     * Move cursor if there is a suffix to prevent user typing past suffix\n     */\n    var handleOnKeyUp = function (event) {\n        var key = event.key, selectionStart = event.currentTarget.selectionStart;\n        if (key !== 'ArrowUp' && key !== 'ArrowDown' && stateValue !== '-') {\n            var suffix_1 = getSuffix(stateValue, { groupSeparator: groupSeparator, decimalSeparator: decimalSeparator });\n            if (suffix_1 && selectionStart && selectionStart > stateValue.length - suffix_1.length) {\n                /* istanbul ignore else */\n                if (inputRef.current) {\n                    var newCursor = stateValue.length - suffix_1.length;\n                    inputRef.current.setSelectionRange(newCursor, newCursor);\n                }\n            }\n        }\n        onKeyUp && onKeyUp(event);\n    };\n    // Update state if userValue changes to undefined\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        if (userValue == null && defaultValue == null) {\n            setStateValue('');\n        }\n    }, [defaultValue, userValue]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        // prevent cursor jumping if editing value\n        if (dirty &&\n            stateValue !== '-' &&\n            inputRef.current &&\n            document.activeElement === inputRef.current) {\n            inputRef.current.setSelectionRange(cursor, cursor);\n        }\n    }, [stateValue, cursor, inputRef, dirty, changeCount]);\n    /**\n     * If user has only entered \"-\" or decimal separator,\n     * keep the char to allow them to enter next value\n     */\n    var getRenderValue = function () {\n        if (userValue != null &&\n            stateValue !== '-' &&\n            (!decimalSeparator || stateValue !== decimalSeparator)) {\n            return formatValue(__assign(__assign({}, formatValueOptions), { decimalScale: dirty ? undefined : decimalScale, value: String(userValue) }));\n        }\n        return stateValue;\n    };\n    var inputProps = __assign({ type: 'text', inputMode: 'decimal', id: id, name: name, className: className, onChange: handleOnChange, onBlur: handleOnBlur, onFocus: handleOnFocus, onKeyDown: handleOnKeyDown, onKeyUp: handleOnKeyUp, placeholder: placeholder, disabled: disabled, value: getRenderValue(), ref: inputRef }, props);\n    if (customInput) {\n        var CustomInput = customInput;\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CustomInput, __assign({}, inputProps));\n    }\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", __assign({}, inputProps));\n});\nCurrencyInput.displayName = 'CurrencyInput';\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY3VycmVuY3ktaW5wdXQtZmllbGQvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUc7O0FBRXJHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseWtCQUF5a0IsbUJBQW1CO0FBQzVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvRkFBb0Y7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxlQUFlLDBEQUFtQix5QkFBeUI7QUFDM0Q7QUFDQSxXQUFXLDBEQUFtQixxQkFBcUI7QUFDbkQsQ0FBQztBQUNEOztBQUU2RDtBQUM3RCIsInNvdXJjZXMiOlsiRTpcXEZpbmFuY2VcXGZpbmFuY2VcXG5vZGVfbW9kdWxlc1xccmVhY3QtY3VycmVuY3ktaW5wdXQtZmllbGRcXGRpc3RcXGluZGV4LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiwgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gIH07XG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICB9XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn07XG5cbi8qKlxuICogRXNjYXBlIHJlZ2V4IGNoYXJcbiAqXG4gKiBTZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3ODg1ODU1L3VzZS1keW5hbWljLXZhcmlhYmxlLXN0cmluZy1hcy1yZWdleC1wYXR0ZXJuLWluLWphdmFzY3JpcHRcbiAqL1xudmFyIGVzY2FwZVJlZ0V4cCA9IGZ1bmN0aW9uIChzdHJpbmdUb0dvSW50b1RoZVJlZ2V4KSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvR29JbnRvVGhlUmVnZXgucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xufTtcblxudmFyIGFiYnJNYXAgPSB7IGs6IDEwMDAsIG06IDEwMDAwMDAsIGI6IDEwMDAwMDAwMDAgfTtcbi8qKlxuICogUGFyc2UgYSB2YWx1ZSB3aXRoIGFiYnJldmlhdGlvbiBlLmcgMWsgPSAxMDAwXG4gKi9cbnZhciBwYXJzZUFiYnJWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVjaW1hbFNlcGFyYXRvcikge1xuICAgIGlmIChkZWNpbWFsU2VwYXJhdG9yID09PSB2b2lkIDApIHsgZGVjaW1hbFNlcGFyYXRvciA9ICcuJzsgfVxuICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKFwiKFxcXFxkKyhcIi5jb25jYXQoZXNjYXBlUmVnRXhwKGRlY2ltYWxTZXBhcmF0b3IpLCBcIlxcXFxkKik/KShba21iXSkkXCIpLCAnaScpO1xuICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKHJlZyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBkaWdpdHMgPSBtYXRjaFsxXSwgYWJiciA9IG1hdGNoWzNdO1xuICAgICAgICB2YXIgbXVsdGlwbGllciA9IGFiYnJNYXBbYWJici50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgcmV0dXJuIE51bWJlcihkaWdpdHMucmVwbGFjZShkZWNpbWFsU2VwYXJhdG9yLCAnLicpKSAqIG11bHRpcGxpZXI7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBncm91cCBzZXBhcmF0b3IgZnJvbSB2YWx1ZSBlZy4gMSwwMDAgPiAxMDAwXG4gKi9cbnZhciByZW1vdmVTZXBhcmF0b3JzID0gZnVuY3Rpb24gKHZhbHVlLCBzZXBhcmF0b3IpIHtcbiAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDApIHsgc2VwYXJhdG9yID0gJywnOyB9XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHNlcGFyYXRvciksICdnJyk7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmVnLCAnJyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBpbnZhbGlkIGNoYXJhY3RlcnNcbiAqL1xudmFyIHJlbW92ZUludmFsaWRDaGFycyA9IGZ1bmN0aW9uICh2YWx1ZSwgdmFsaWRDaGFycykge1xuICAgIHZhciBjaGFycyA9IGVzY2FwZVJlZ0V4cCh2YWxpZENoYXJzLmpvaW4oJycpKTtcbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIlteXFxcXGRcIi5jb25jYXQoY2hhcnMsIFwiXVwiKSwgJ2dpJyk7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmVnLCAnJyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBwcmVmaXgsIHNlcGFyYXRvcnMgYW5kIGV4dHJhIGRlY2ltYWxzIGZyb20gdmFsdWVcbiAqL1xudmFyIGNsZWFuVmFsdWUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZSwgX2IgPSBfYS5ncm91cFNlcGFyYXRvciwgZ3JvdXBTZXBhcmF0b3IgPSBfYiA9PT0gdm9pZCAwID8gJywnIDogX2IsIF9jID0gX2EuZGVjaW1hbFNlcGFyYXRvciwgZGVjaW1hbFNlcGFyYXRvciA9IF9jID09PSB2b2lkIDAgPyAnLicgOiBfYywgX2QgPSBfYS5hbGxvd0RlY2ltYWxzLCBhbGxvd0RlY2ltYWxzID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCwgX2UgPSBfYS5kZWNpbWFsc0xpbWl0LCBkZWNpbWFsc0xpbWl0ID0gX2UgPT09IHZvaWQgMCA/IDIgOiBfZSwgX2YgPSBfYS5hbGxvd05lZ2F0aXZlVmFsdWUsIGFsbG93TmVnYXRpdmVWYWx1ZSA9IF9mID09PSB2b2lkIDAgPyB0cnVlIDogX2YsIF9nID0gX2EuZGlzYWJsZUFiYnJldmlhdGlvbnMsIGRpc2FibGVBYmJyZXZpYXRpb25zID0gX2cgPT09IHZvaWQgMCA/IGZhbHNlIDogX2csIF9oID0gX2EucHJlZml4LCBwcmVmaXggPSBfaCA9PT0gdm9pZCAwID8gJycgOiBfaCwgX2ogPSBfYS50cmFuc2Zvcm1SYXdWYWx1ZSwgdHJhbnNmb3JtUmF3VmFsdWUgPSBfaiA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHJhd1ZhbHVlKSB7IHJldHVybiByYXdWYWx1ZTsgfSA6IF9qO1xuICAgIHZhciB0cmFuc2Zvcm1lZFZhbHVlID0gdHJhbnNmb3JtUmF3VmFsdWUodmFsdWUpO1xuICAgIGlmICh0cmFuc2Zvcm1lZFZhbHVlID09PSAnLScpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkVmFsdWU7XG4gICAgfVxuICAgIHZhciBhYmJyZXZpYXRpb25zID0gZGlzYWJsZUFiYnJldmlhdGlvbnMgPyBbXSA6IFsnaycsICdtJywgJ2InXTtcbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIigoXnxcXFxcRCktXFxcXGQpfCgtXCIuY29uY2F0KGVzY2FwZVJlZ0V4cChwcmVmaXgpLCBcIilcIikpO1xuICAgIHZhciBpc05lZ2F0aXZlID0gcmVnLnRlc3QodHJhbnNmb3JtZWRWYWx1ZSk7XG4gICAgLy8gSXMgdGhlcmUgYSBkaWdpdCBiZWZvcmUgdGhlIHByZWZpeD8gZWcuIDEkXG4gICAgdmFyIF9rID0gUmVnRXhwKFwiKFxcXFxkKyktP1wiLmNvbmNhdChlc2NhcGVSZWdFeHAocHJlZml4KSkpLmV4ZWModmFsdWUpIHx8IFtdLCBwcmVmaXhXaXRoVmFsdWUgPSBfa1swXSwgcHJlVmFsdWUgPSBfa1sxXTtcbiAgICB2YXIgd2l0aG91dFByZWZpeCA9IHByZWZpeFxuICAgICAgICA/IHByZWZpeFdpdGhWYWx1ZVxuICAgICAgICAgICAgPyB0cmFuc2Zvcm1lZFZhbHVlLnJlcGxhY2UocHJlZml4V2l0aFZhbHVlLCAnJykuY29uY2F0KHByZVZhbHVlKVxuICAgICAgICAgICAgOiB0cmFuc2Zvcm1lZFZhbHVlLnJlcGxhY2UocHJlZml4LCAnJylcbiAgICAgICAgOiB0cmFuc2Zvcm1lZFZhbHVlO1xuICAgIHZhciB3aXRob3V0U2VwYXJhdG9ycyA9IHJlbW92ZVNlcGFyYXRvcnMod2l0aG91dFByZWZpeCwgZ3JvdXBTZXBhcmF0b3IpO1xuICAgIHZhciB3aXRob3V0SW52YWxpZENoYXJzID0gcmVtb3ZlSW52YWxpZENoYXJzKHdpdGhvdXRTZXBhcmF0b3JzLCBfX3NwcmVhZEFycmF5KFtcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3IsXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3JcbiAgICBdLCBhYmJyZXZpYXRpb25zLCB0cnVlKSk7XG4gICAgdmFyIHZhbHVlT25seSA9IHdpdGhvdXRJbnZhbGlkQ2hhcnM7XG4gICAgaWYgKCFkaXNhYmxlQWJicmV2aWF0aW9ucykge1xuICAgICAgICAvLyBkaXNhbGxvdyBsZXR0ZXIgd2l0aG91dCBudW1iZXJcbiAgICAgICAgaWYgKGFiYnJldmlhdGlvbnMuc29tZShmdW5jdGlvbiAobGV0dGVyKSB7IHJldHVybiBsZXR0ZXIgPT09IHdpdGhvdXRJbnZhbGlkQ2hhcnMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKGRlY2ltYWxTZXBhcmF0b3IsICcnKTsgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VBYmJyVmFsdWUod2l0aG91dEludmFsaWRDaGFycywgZGVjaW1hbFNlcGFyYXRvcik7XG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgIHZhbHVlT25seSA9IFN0cmluZyhwYXJzZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBpbmNsdWRlTmVnYXRpdmUgPSBpc05lZ2F0aXZlICYmIGFsbG93TmVnYXRpdmVWYWx1ZSA/ICctJyA6ICcnO1xuICAgIGlmIChkZWNpbWFsU2VwYXJhdG9yICYmIHZhbHVlT25seS5pbmNsdWRlcyhkZWNpbWFsU2VwYXJhdG9yKSkge1xuICAgICAgICB2YXIgX2wgPSB3aXRob3V0SW52YWxpZENoYXJzLnNwbGl0KGRlY2ltYWxTZXBhcmF0b3IpLCBpbnQgPSBfbFswXSwgZGVjaW1hbHMgPSBfbFsxXTtcbiAgICAgICAgdmFyIHRyaW1tZWREZWNpbWFscyA9IGRlY2ltYWxzTGltaXQgJiYgZGVjaW1hbHMgPyBkZWNpbWFscy5zbGljZSgwLCBkZWNpbWFsc0xpbWl0KSA6IGRlY2ltYWxzO1xuICAgICAgICB2YXIgaW5jbHVkZURlY2ltYWxzID0gYWxsb3dEZWNpbWFscyA/IFwiXCIuY29uY2F0KGRlY2ltYWxTZXBhcmF0b3IpLmNvbmNhdCh0cmltbWVkRGVjaW1hbHMpIDogJyc7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChpbmNsdWRlTmVnYXRpdmUpLmNvbmNhdChpbnQpLmNvbmNhdChpbmNsdWRlRGVjaW1hbHMpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoaW5jbHVkZU5lZ2F0aXZlKS5jb25jYXQodmFsdWVPbmx5KTtcbn07XG5cbnZhciBmaXhlZERlY2ltYWxWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVjaW1hbFNlcGFyYXRvciwgZml4ZWREZWNpbWFsTGVuZ3RoKSB7XG4gICAgaWYgKGZpeGVkRGVjaW1hbExlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKGZpeGVkRGVjaW1hbExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoZGVjaW1hbFNlcGFyYXRvciwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhkZWNpbWFsU2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgdmFyIF9hID0gdmFsdWUuc3BsaXQoZGVjaW1hbFNlcGFyYXRvciksIGludCA9IF9hWzBdLCBkZWNpbWFscyA9IF9hWzFdO1xuICAgICAgICAgICAgaWYgKGRlY2ltYWxzLmxlbmd0aCA9PT0gZml4ZWREZWNpbWFsTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY2ltYWxzLmxlbmd0aCA+IGZpeGVkRGVjaW1hbExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChpbnQpLmNvbmNhdChkZWNpbWFsU2VwYXJhdG9yKS5jb25jYXQoZGVjaW1hbHMuc2xpY2UoMCwgZml4ZWREZWNpbWFsTGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZyA9IHZhbHVlLmxlbmd0aCA+IGZpeGVkRGVjaW1hbExlbmd0aFxuICAgICAgICAgICAgPyBuZXcgUmVnRXhwKFwiKFxcXFxkKykoXFxcXGR7XCIuY29uY2F0KGZpeGVkRGVjaW1hbExlbmd0aCwgXCJ9KVwiKSlcbiAgICAgICAgICAgIDogbmV3IFJlZ0V4cChcIihcXFxcZCkoXFxcXGQrKVwiKTtcbiAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocmVnKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgaW50ID0gbWF0Y2hbMV0sIGRlY2ltYWxzID0gbWF0Y2hbMl07XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoaW50KS5jb25jYXQoZGVjaW1hbFNlcGFyYXRvcikuY29uY2F0KGRlY2ltYWxzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2V0U3VmZml4ID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgIHZhciBfYiA9IF9hLmdyb3VwU2VwYXJhdG9yLCBncm91cFNlcGFyYXRvciA9IF9iID09PSB2b2lkIDAgPyAnLCcgOiBfYiwgX2MgPSBfYS5kZWNpbWFsU2VwYXJhdG9yLCBkZWNpbWFsU2VwYXJhdG9yID0gX2MgPT09IHZvaWQgMCA/ICcuJyA6IF9jO1xuICAgIHZhciBzdWZmaXhSZWcgPSBuZXcgUmVnRXhwKFwiXFxcXGQoW15cIi5jb25jYXQoZXNjYXBlUmVnRXhwKGdyb3VwU2VwYXJhdG9yKSkuY29uY2F0KGVzY2FwZVJlZ0V4cChkZWNpbWFsU2VwYXJhdG9yKSwgXCIwLTldKylcIikpO1xuICAgIHZhciBzdWZmaXhNYXRjaCA9IHZhbHVlLm1hdGNoKHN1ZmZpeFJlZyk7XG4gICAgcmV0dXJuIHN1ZmZpeE1hdGNoID8gc3VmZml4TWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEZvcm1hdCB2YWx1ZSB3aXRoIGRlY2ltYWwgc2VwYXJhdG9yLCBncm91cCBzZXBhcmF0b3IgYW5kIHByZWZpeFxuICovXG52YXIgZm9ybWF0VmFsdWUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBfdmFsdWUgPSBvcHRpb25zLnZhbHVlLCBkZWNpbWFsU2VwYXJhdG9yID0gb3B0aW9ucy5kZWNpbWFsU2VwYXJhdG9yLCBpbnRsQ29uZmlnID0gb3B0aW9ucy5pbnRsQ29uZmlnLCBkZWNpbWFsU2NhbGUgPSBvcHRpb25zLmRlY2ltYWxTY2FsZSwgX2EgPSBvcHRpb25zLnByZWZpeCwgcHJlZml4ID0gX2EgPT09IHZvaWQgMCA/ICcnIDogX2EsIF9iID0gb3B0aW9ucy5zdWZmaXgsIHN1ZmZpeCA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xuICAgIGlmIChfdmFsdWUgPT09ICcnIHx8IF92YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKF92YWx1ZSA9PT0gJy0nKSB7XG4gICAgICAgIHJldHVybiAnLSc7XG4gICAgfVxuICAgIHZhciBpc05lZ2F0aXZlID0gbmV3IFJlZ0V4cChcIl5cXFxcZD8tXCIuY29uY2F0KHByZWZpeCA/IFwiXCIuY29uY2F0KGVzY2FwZVJlZ0V4cChwcmVmaXgpLCBcIj9cIikgOiAnJywgXCJcXFxcZFwiKSkudGVzdChfdmFsdWUpO1xuICAgIHZhciB2YWx1ZSA9IGRlY2ltYWxTZXBhcmF0b3IgIT09ICcuJ1xuICAgICAgICA/IHJlcGxhY2VEZWNpbWFsU2VwYXJhdG9yKF92YWx1ZSwgZGVjaW1hbFNlcGFyYXRvciwgaXNOZWdhdGl2ZSlcbiAgICAgICAgOiBfdmFsdWU7XG4gICAgaWYgKGRlY2ltYWxTZXBhcmF0b3IgJiYgZGVjaW1hbFNlcGFyYXRvciAhPT0gJy0nICYmIHZhbHVlLnN0YXJ0c1dpdGgoZGVjaW1hbFNlcGFyYXRvcikpIHtcbiAgICAgICAgdmFsdWUgPSAnMCcgKyB2YWx1ZTtcbiAgICB9XG4gICAgdmFyIGRlZmF1bHROdW1iZXJGb3JtYXRPcHRpb25zID0ge1xuICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IGRlY2ltYWxTY2FsZSB8fCAwLFxuICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIwLFxuICAgIH07XG4gICAgdmFyIG51bWJlckZvcm1hdHRlciA9IGludGxDb25maWdcbiAgICAgICAgPyBuZXcgSW50bC5OdW1iZXJGb3JtYXQoaW50bENvbmZpZy5sb2NhbGUsIGludGxDb25maWcuY3VycmVuY3lcbiAgICAgICAgICAgID8gX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHROdW1iZXJGb3JtYXRPcHRpb25zKSwgeyBzdHlsZTogJ2N1cnJlbmN5JywgY3VycmVuY3k6IGludGxDb25maWcuY3VycmVuY3kgfSkgOiBkZWZhdWx0TnVtYmVyRm9ybWF0T3B0aW9ucylcbiAgICAgICAgOiBuZXcgSW50bC5OdW1iZXJGb3JtYXQodW5kZWZpbmVkLCBkZWZhdWx0TnVtYmVyRm9ybWF0T3B0aW9ucyk7XG4gICAgdmFyIHBhcnRzID0gbnVtYmVyRm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoTnVtYmVyKHZhbHVlKSk7XG4gICAgdmFyIGZvcm1hdHRlZCA9IHJlcGxhY2VQYXJ0cyhwYXJ0cywgb3B0aW9ucyk7XG4gICAgLy8gRG9lcyBpbnRsIGZvcm1hdHRpbmcgYWRkIGEgc3VmZml4P1xuICAgIHZhciBpbnRsU3VmZml4ID0gZ2V0U3VmZml4KGZvcm1hdHRlZCwgX19hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgICAvLyBJbmNsdWRlIGRlY2ltYWwgc2VwYXJhdG9yIGlmIHVzZXIgaW5wdXQgZW5kcyB3aXRoIGRlY2ltYWwgc2VwYXJhdG9yXG4gICAgdmFyIGluY2x1ZGVEZWNpbWFsU2VwYXJhdG9yID0gX3ZhbHVlLnNsaWNlKC0xKSA9PT0gZGVjaW1hbFNlcGFyYXRvciA/IGRlY2ltYWxTZXBhcmF0b3IgOiAnJztcbiAgICB2YXIgX2MgPSB2YWx1ZS5tYXRjaChSZWdFeHAoJ1xcXFxkK1xcXFwuKFxcXFxkKyknKSkgfHwgW10sIGRlY2ltYWxzID0gX2NbMV07XG4gICAgLy8gS2VlcCBvcmlnaW5hbCBkZWNpbWFsIHBhZGRpbmcgaWYgbm8gZGVjaW1hbFNjYWxlXG4gICAgaWYgKGRlY2ltYWxTY2FsZSA9PT0gdW5kZWZpbmVkICYmIGRlY2ltYWxzICYmIGRlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICAgICAgaWYgKGZvcm1hdHRlZC5pbmNsdWRlcyhkZWNpbWFsU2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnJlcGxhY2UoUmVnRXhwKFwiKFxcXFxkKykoXCIuY29uY2F0KGVzY2FwZVJlZ0V4cChkZWNpbWFsU2VwYXJhdG9yKSwgXCIpKFxcXFxkKylcIiksICdnJyksIFwiJDEkMlwiLmNvbmNhdChkZWNpbWFscykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGludGxTdWZmaXggJiYgIXN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKGludGxTdWZmaXgsIFwiXCIuY29uY2F0KGRlY2ltYWxTZXBhcmF0b3IpLmNvbmNhdChkZWNpbWFscykuY29uY2F0KGludGxTdWZmaXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZCA9IFwiXCIuY29uY2F0KGZvcm1hdHRlZCkuY29uY2F0KGRlY2ltYWxTZXBhcmF0b3IpLmNvbmNhdChkZWNpbWFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN1ZmZpeCAmJiBpbmNsdWRlRGVjaW1hbFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZm9ybWF0dGVkKS5jb25jYXQoaW5jbHVkZURlY2ltYWxTZXBhcmF0b3IpLmNvbmNhdChzdWZmaXgpO1xuICAgIH1cbiAgICBpZiAoaW50bFN1ZmZpeCAmJiBpbmNsdWRlRGVjaW1hbFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVkLnJlcGxhY2UoaW50bFN1ZmZpeCwgXCJcIi5jb25jYXQoaW5jbHVkZURlY2ltYWxTZXBhcmF0b3IpLmNvbmNhdChpbnRsU3VmZml4KSk7XG4gICAgfVxuICAgIGlmIChpbnRsU3VmZml4ICYmIHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVkLnJlcGxhY2UoaW50bFN1ZmZpeCwgXCJcIi5jb25jYXQoaW5jbHVkZURlY2ltYWxTZXBhcmF0b3IpLmNvbmNhdChzdWZmaXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIFtmb3JtYXR0ZWQsIGluY2x1ZGVEZWNpbWFsU2VwYXJhdG9yLCBzdWZmaXhdLmpvaW4oJycpO1xufTtcbi8qKlxuICogQmVmb3JlIGNvbnZlcnRpbmcgdG8gTnVtYmVyLCBkZWNpbWFsIHNlcGFyYXRvciBoYXMgdG8gYmUgLlxuICovXG52YXIgcmVwbGFjZURlY2ltYWxTZXBhcmF0b3IgPSBmdW5jdGlvbiAodmFsdWUsIGRlY2ltYWxTZXBhcmF0b3IsIGlzTmVnYXRpdmUpIHtcbiAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAoZGVjaW1hbFNlcGFyYXRvciAmJiBkZWNpbWFsU2VwYXJhdG9yICE9PSAnLicpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS5yZXBsYWNlKFJlZ0V4cChlc2NhcGVSZWdFeHAoZGVjaW1hbFNlcGFyYXRvciksICdnJyksICcuJyk7XG4gICAgICAgIGlmIChpc05lZ2F0aXZlICYmIGRlY2ltYWxTZXBhcmF0b3IgPT09ICctJykge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBcIi1cIi5jb25jYXQobmV3VmFsdWUuc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbn07XG52YXIgcmVwbGFjZVBhcnRzID0gZnVuY3Rpb24gKHBhcnRzLCBfYSkge1xuICAgIHZhciBwcmVmaXggPSBfYS5wcmVmaXgsIGdyb3VwU2VwYXJhdG9yID0gX2EuZ3JvdXBTZXBhcmF0b3IsIGRlY2ltYWxTZXBhcmF0b3IgPSBfYS5kZWNpbWFsU2VwYXJhdG9yLCBkZWNpbWFsU2NhbGUgPSBfYS5kZWNpbWFsU2NhbGUsIF9iID0gX2EuZGlzYWJsZUdyb3VwU2VwYXJhdG9ycywgZGlzYWJsZUdyb3VwU2VwYXJhdG9ycyA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iO1xuICAgIHJldHVybiBwYXJ0c1xuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBfYSwgaSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgIGlmIChpID09PSAwICYmIHByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtaW51c1NpZ24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt2YWx1ZSwgcHJlZml4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnY3VycmVuY3knKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcHJldiwgdHJ1ZSksIFtwcmVmaXhdLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3ByZWZpeCwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY3VycmVuY3knKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ID8gcHJldiA6IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcHJldiwgdHJ1ZSksIFt2YWx1ZV0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgcmV0dXJuICFkaXNhYmxlR3JvdXBTZXBhcmF0b3JzXG4gICAgICAgICAgICAgICAgPyBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHByZXYsIHRydWUpLCBbZ3JvdXBTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IGdyb3VwU2VwYXJhdG9yIDogdmFsdWVdLCBmYWxzZSkgOiBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGVjaW1hbCcpIHtcbiAgICAgICAgICAgIGlmIChkZWNpbWFsU2NhbGUgIT09IHVuZGVmaW5lZCAmJiBkZWNpbWFsU2NhbGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHByZXYsIHRydWUpLCBbZGVjaW1hbFNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gZGVjaW1hbFNlcGFyYXRvciA6IHZhbHVlXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZnJhY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBwcmV2LCB0cnVlKSwgW2RlY2ltYWxTY2FsZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc2xpY2UoMCwgZGVjaW1hbFNjYWxlKSA6IHZhbHVlXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHByZXYsIHRydWUpLCBbdmFsdWVdLCBmYWxzZSk7XG4gICAgfSwgWycnXSlcbiAgICAgICAgLmpvaW4oJycpO1xufTtcblxudmFyIGRlZmF1bHRDb25maWcgPSB7XG4gICAgY3VycmVuY3lTeW1ib2w6ICcnLFxuICAgIGdyb3VwU2VwYXJhdG9yOiAnJyxcbiAgICBkZWNpbWFsU2VwYXJhdG9yOiAnJyxcbiAgICBwcmVmaXg6ICcnLFxuICAgIHN1ZmZpeDogJycsXG59O1xuLyoqXG4gKiBHZXQgbG9jYWxlIGNvbmZpZyBmcm9tIGlucHV0IG9yIGRlZmF1bHRcbiAqL1xudmFyIGdldExvY2FsZUNvbmZpZyA9IGZ1bmN0aW9uIChpbnRsQ29uZmlnKSB7XG4gICAgdmFyIF9hID0gaW50bENvbmZpZyB8fCB7fSwgbG9jYWxlID0gX2EubG9jYWxlLCBjdXJyZW5jeSA9IF9hLmN1cnJlbmN5O1xuICAgIHZhciBudW1iZXJGb3JtYXR0ZXIgPSBsb2NhbGVcbiAgICAgICAgPyBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBjdXJyZW5jeSA/IHsgY3VycmVuY3k6IGN1cnJlbmN5LCBzdHlsZTogJ2N1cnJlbmN5JyB9IDogdW5kZWZpbmVkKVxuICAgICAgICA6IG5ldyBJbnRsLk51bWJlckZvcm1hdCgpO1xuICAgIHJldHVybiBudW1iZXJGb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cygxMDAwLjEpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyciwgaSkge1xuICAgICAgICBpZiAoY3Vyci50eXBlID09PSAnY3VycmVuY3knKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldiksIHsgY3VycmVuY3lTeW1ib2w6IGN1cnIudmFsdWUsIHByZWZpeDogY3Vyci52YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldiksIHsgY3VycmVuY3lTeW1ib2w6IGN1cnIudmFsdWUsIHN1ZmZpeDogY3Vyci52YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3Vyci50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXYpLCB7IGdyb3VwU2VwYXJhdG9yOiBjdXJyLnZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyLnR5cGUgPT09ICdkZWNpbWFsJykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2KSwgeyBkZWNpbWFsU2VwYXJhdG9yOiBjdXJyLnZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgIH0sIGRlZmF1bHRDb25maWcpO1xufTtcblxudmFyIGlzTnVtYmVyID0gZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBSZWdFeHAoL1xcZC8sICdnaScpLnRlc3QoaW5wdXQpOyB9O1xuXG52YXIgcGFkVHJpbVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBkZWNpbWFsU2VwYXJhdG9yLCBkZWNpbWFsU2NhbGUpIHtcbiAgICBpZiAoZGVjaW1hbFNlcGFyYXRvciA9PT0gdm9pZCAwKSB7IGRlY2ltYWxTZXBhcmF0b3IgPSAnLic7IH1cbiAgICBpZiAoZGVjaW1hbFNjYWxlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlLm1hdGNoKC9cXGQvZykpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgX2EgPSB2YWx1ZS5zcGxpdChkZWNpbWFsU2VwYXJhdG9yKSwgaW50ID0gX2FbMF0sIGRlY2ltYWxzID0gX2FbMV07XG4gICAgaWYgKGRlY2ltYWxTY2FsZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaW50O1xuICAgIH1cbiAgICB2YXIgbmV3VmFsdWUgPSBkZWNpbWFscyB8fCAnJztcbiAgICBpZiAobmV3VmFsdWUubGVuZ3RoIDwgZGVjaW1hbFNjYWxlKSB7XG4gICAgICAgIHdoaWxlIChuZXdWYWx1ZS5sZW5ndGggPCBkZWNpbWFsU2NhbGUpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlICs9ICcwJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS5zbGljZSgwLCBkZWNpbWFsU2NhbGUpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoaW50KS5jb25jYXQoZGVjaW1hbFNlcGFyYXRvcikuY29uY2F0KG5ld1ZhbHVlKTtcbn07XG5cbi8qKlxuICogQmFzZWQgb24gdGhlIGxhc3Qga2V5IHN0cm9rZSBhbmQgdGhlIGN1cnNvciBwb3NpdGlvbiwgdXBkYXRlIHRoZSB2YWx1ZVxuICogYW5kIHJlcG9zaXRpb24gdGhlIGN1cnNvciB0byB0aGUgcmlnaHQgcGxhY2VcbiAqL1xudmFyIHJlcG9zaXRpb25DdXJzb3IgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSBfYS5zZWxlY3Rpb25TdGFydCwgdmFsdWUgPSBfYS52YWx1ZSwgbGFzdEtleVN0cm9rZSA9IF9hLmxhc3RLZXlTdHJva2UsIHN0YXRlVmFsdWUgPSBfYS5zdGF0ZVZhbHVlLCBncm91cFNlcGFyYXRvciA9IF9hLmdyb3VwU2VwYXJhdG9yO1xuICAgIHZhciBjdXJzb3JQb3NpdGlvbiA9IHNlbGVjdGlvblN0YXJ0O1xuICAgIHZhciBtb2RpZmllZFZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHN0YXRlVmFsdWUgJiYgY3Vyc29yUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHNwbGl0VmFsdWUgPSB2YWx1ZS5zcGxpdCgnJyk7XG4gICAgICAgIC8vIGlmIGN1cnNvciBpcyB0byByaWdodCBvZiBncm91cFNlcGFyYXRvciBhbmQgYmFja3NwYWNlIHByZXNzZWQsIGRlbGV0ZSB0aGUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0IG9mIHRoZSBzZXBhcmF0b3IgYW5kIHJlcG9zaXRpb24gdGhlIGN1cnNvclxuICAgICAgICBpZiAobGFzdEtleVN0cm9rZSA9PT0gJ0JhY2tzcGFjZScgJiYgc3RhdGVWYWx1ZVtjdXJzb3JQb3NpdGlvbl0gPT09IGdyb3VwU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBzcGxpdFZhbHVlLnNwbGljZShjdXJzb3JQb3NpdGlvbiAtIDEsIDEpO1xuICAgICAgICAgICAgY3Vyc29yUG9zaXRpb24gLT0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBjdXJzb3IgaXMgdG8gbGVmdCBvZiBncm91cFNlcGFyYXRvciBhbmQgZGVsZXRlIHByZXNzZWQsIGRlbGV0ZSB0aGUgY2hhcmFjdGVyIHRvIHRoZSByaWdodCBvZiB0aGUgc2VwYXJhdG9yIGFuZCByZXBvc2l0aW9uIHRoZSBjdXJzb3JcbiAgICAgICAgaWYgKGxhc3RLZXlTdHJva2UgPT09ICdEZWxldGUnICYmIHN0YXRlVmFsdWVbY3Vyc29yUG9zaXRpb25dID09PSBncm91cFNlcGFyYXRvcikge1xuICAgICAgICAgICAgc3BsaXRWYWx1ZS5zcGxpY2UoY3Vyc29yUG9zaXRpb24sIDEpO1xuICAgICAgICAgICAgY3Vyc29yUG9zaXRpb24gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBtb2RpZmllZFZhbHVlID0gc3BsaXRWYWx1ZS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWRWYWx1ZTogbW9kaWZpZWRWYWx1ZSwgY3Vyc29yUG9zaXRpb246IGN1cnNvclBvc2l0aW9uIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkVmFsdWU6IG1vZGlmaWVkVmFsdWUsIGN1cnNvclBvc2l0aW9uOiBzZWxlY3Rpb25TdGFydCB9O1xufTtcblxudmFyIEN1cnJlbmN5SW5wdXQgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIChfYSwgcmVmKSB7XG4gICAgdmFyIF9iID0gX2EuYWxsb3dEZWNpbWFscywgYWxsb3dEZWNpbWFscyA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gX2EuYWxsb3dOZWdhdGl2ZVZhbHVlLCBhbGxvd05lZ2F0aXZlVmFsdWUgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBpZCA9IF9hLmlkLCBuYW1lID0gX2EubmFtZSwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBjdXN0b21JbnB1dCA9IF9hLmN1c3RvbUlucHV0LCBkZWNpbWFsc0xpbWl0ID0gX2EuZGVjaW1hbHNMaW1pdCwgZGVmYXVsdFZhbHVlID0gX2EuZGVmYXVsdFZhbHVlLCBfZCA9IF9hLmRpc2FibGVkLCBkaXNhYmxlZCA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kLCB1c2VyTWF4TGVuZ3RoID0gX2EubWF4TGVuZ3RoLCB1c2VyVmFsdWUgPSBfYS52YWx1ZSwgb25WYWx1ZUNoYW5nZSA9IF9hLm9uVmFsdWVDaGFuZ2UsIGZpeGVkRGVjaW1hbExlbmd0aCA9IF9hLmZpeGVkRGVjaW1hbExlbmd0aCwgcGxhY2Vob2xkZXIgPSBfYS5wbGFjZWhvbGRlciwgZGVjaW1hbFNjYWxlID0gX2EuZGVjaW1hbFNjYWxlLCBwcmVmaXggPSBfYS5wcmVmaXgsIHN1ZmZpeCA9IF9hLnN1ZmZpeCwgaW50bENvbmZpZyA9IF9hLmludGxDb25maWcsIHN0ZXAgPSBfYS5zdGVwLCBtaW4gPSBfYS5taW4sIG1heCA9IF9hLm1heCwgX2UgPSBfYS5kaXNhYmxlR3JvdXBTZXBhcmF0b3JzLCBkaXNhYmxlR3JvdXBTZXBhcmF0b3JzID0gX2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX2UsIF9mID0gX2EuZGlzYWJsZUFiYnJldmlhdGlvbnMsIGRpc2FibGVBYmJyZXZpYXRpb25zID0gX2YgPT09IHZvaWQgMCA/IGZhbHNlIDogX2YsIF9kZWNpbWFsU2VwYXJhdG9yID0gX2EuZGVjaW1hbFNlcGFyYXRvciwgX2dyb3VwU2VwYXJhdG9yID0gX2EuZ3JvdXBTZXBhcmF0b3IsIG9uQ2hhbmdlID0gX2Eub25DaGFuZ2UsIG9uRm9jdXMgPSBfYS5vbkZvY3VzLCBvbkJsdXIgPSBfYS5vbkJsdXIsIG9uS2V5RG93biA9IF9hLm9uS2V5RG93biwgb25LZXlVcCA9IF9hLm9uS2V5VXAsIHRyYW5zZm9ybVJhd1ZhbHVlID0gX2EudHJhbnNmb3JtUmF3VmFsdWUsIF9nID0gX2EuZm9ybWF0VmFsdWVPbkJsdXIsIGZvcm1hdFZhbHVlT25CbHVyID0gX2cgPT09IHZvaWQgMCA/IHRydWUgOiBfZywgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImFsbG93RGVjaW1hbHNcIiwgXCJhbGxvd05lZ2F0aXZlVmFsdWVcIiwgXCJpZFwiLCBcIm5hbWVcIiwgXCJjbGFzc05hbWVcIiwgXCJjdXN0b21JbnB1dFwiLCBcImRlY2ltYWxzTGltaXRcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJkaXNhYmxlZFwiLCBcIm1heExlbmd0aFwiLCBcInZhbHVlXCIsIFwib25WYWx1ZUNoYW5nZVwiLCBcImZpeGVkRGVjaW1hbExlbmd0aFwiLCBcInBsYWNlaG9sZGVyXCIsIFwiZGVjaW1hbFNjYWxlXCIsIFwicHJlZml4XCIsIFwic3VmZml4XCIsIFwiaW50bENvbmZpZ1wiLCBcInN0ZXBcIiwgXCJtaW5cIiwgXCJtYXhcIiwgXCJkaXNhYmxlR3JvdXBTZXBhcmF0b3JzXCIsIFwiZGlzYWJsZUFiYnJldmlhdGlvbnNcIiwgXCJkZWNpbWFsU2VwYXJhdG9yXCIsIFwiZ3JvdXBTZXBhcmF0b3JcIiwgXCJvbkNoYW5nZVwiLCBcIm9uRm9jdXNcIiwgXCJvbkJsdXJcIiwgXCJvbktleURvd25cIiwgXCJvbktleVVwXCIsIFwidHJhbnNmb3JtUmF3VmFsdWVcIiwgXCJmb3JtYXRWYWx1ZU9uQmx1clwiXSk7XG4gICAgaWYgKF9kZWNpbWFsU2VwYXJhdG9yICYmIGlzTnVtYmVyKF9kZWNpbWFsU2VwYXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY2ltYWxTZXBhcmF0b3IgY2Fubm90IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmIChfZ3JvdXBTZXBhcmF0b3IgJiYgaXNOdW1iZXIoX2dyb3VwU2VwYXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dyb3VwU2VwYXJhdG9yIGNhbm5vdCBiZSBhIG51bWJlcicpO1xuICAgIH1cbiAgICB2YXIgbG9jYWxlQ29uZmlnID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRMb2NhbGVDb25maWcoaW50bENvbmZpZyk7IH0sIFtpbnRsQ29uZmlnXSk7XG4gICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSBfZGVjaW1hbFNlcGFyYXRvciB8fCBsb2NhbGVDb25maWcuZGVjaW1hbFNlcGFyYXRvciB8fCAnJztcbiAgICB2YXIgZ3JvdXBTZXBhcmF0b3IgPSBfZ3JvdXBTZXBhcmF0b3IgfHwgbG9jYWxlQ29uZmlnLmdyb3VwU2VwYXJhdG9yIHx8ICcnO1xuICAgIGlmIChkZWNpbWFsU2VwYXJhdG9yICYmXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yICYmXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3IgPT09IGdyb3VwU2VwYXJhdG9yICYmXG4gICAgICAgIGRpc2FibGVHcm91cFNlcGFyYXRvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVjaW1hbFNlcGFyYXRvciBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgZ3JvdXBTZXBhcmF0b3InKTtcbiAgICB9XG4gICAgdmFyIGZvcm1hdFZhbHVlT3B0aW9ucyA9IHtcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogZGVjaW1hbFNlcGFyYXRvcixcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6IGdyb3VwU2VwYXJhdG9yLFxuICAgICAgICBkaXNhYmxlR3JvdXBTZXBhcmF0b3JzOiBkaXNhYmxlR3JvdXBTZXBhcmF0b3JzLFxuICAgICAgICBpbnRsQ29uZmlnOiBpbnRsQ29uZmlnLFxuICAgICAgICBwcmVmaXg6IHByZWZpeCB8fCBsb2NhbGVDb25maWcucHJlZml4LFxuICAgICAgICBzdWZmaXg6IHN1ZmZpeCxcbiAgICB9O1xuICAgIHZhciBjbGVhblZhbHVlT3B0aW9ucyA9IHtcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogZGVjaW1hbFNlcGFyYXRvcixcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6IGdyb3VwU2VwYXJhdG9yLFxuICAgICAgICBhbGxvd0RlY2ltYWxzOiBhbGxvd0RlY2ltYWxzLFxuICAgICAgICBkZWNpbWFsc0xpbWl0OiBkZWNpbWFsc0xpbWl0IHx8IGZpeGVkRGVjaW1hbExlbmd0aCB8fCAyLFxuICAgICAgICBhbGxvd05lZ2F0aXZlVmFsdWU6IGFsbG93TmVnYXRpdmVWYWx1ZSxcbiAgICAgICAgZGlzYWJsZUFiYnJldmlhdGlvbnM6IGRpc2FibGVBYmJyZXZpYXRpb25zLFxuICAgICAgICBwcmVmaXg6IHByZWZpeCB8fCBsb2NhbGVDb25maWcucHJlZml4LFxuICAgICAgICB0cmFuc2Zvcm1SYXdWYWx1ZTogdHJhbnNmb3JtUmF3VmFsdWUsXG4gICAgfTtcbiAgICB2YXIgX2ggPSB1c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUgIT0gbnVsbFxuICAgICAgICAgICAgPyBmb3JtYXRWYWx1ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZm9ybWF0VmFsdWVPcHRpb25zKSwgeyBkZWNpbWFsU2NhbGU6IGRlY2ltYWxTY2FsZSwgdmFsdWU6IFN0cmluZyhkZWZhdWx0VmFsdWUpIH0pKVxuICAgICAgICAgICAgOiB1c2VyVmFsdWUgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZm9ybWF0VmFsdWUoX19hc3NpZ24oX19hc3NpZ24oe30sIGZvcm1hdFZhbHVlT3B0aW9ucyksIHsgZGVjaW1hbFNjYWxlOiBkZWNpbWFsU2NhbGUsIHZhbHVlOiBTdHJpbmcodXNlclZhbHVlKSB9KSlcbiAgICAgICAgICAgICAgICA6ICcnO1xuICAgIH0pLCBzdGF0ZVZhbHVlID0gX2hbMF0sIHNldFN0YXRlVmFsdWUgPSBfaFsxXTtcbiAgICB2YXIgX2ogPSB1c2VTdGF0ZShmYWxzZSksIGRpcnR5ID0gX2pbMF0sIHNldERpcnR5ID0gX2pbMV07XG4gICAgdmFyIF9rID0gdXNlU3RhdGUoMCksIGN1cnNvciA9IF9rWzBdLCBzZXRDdXJzb3IgPSBfa1sxXTtcbiAgICB2YXIgX2wgPSB1c2VTdGF0ZSgwKSwgY2hhbmdlQ291bnQgPSBfbFswXSwgc2V0Q2hhbmdlQ291bnQgPSBfbFsxXTtcbiAgICB2YXIgX20gPSB1c2VTdGF0ZShudWxsKSwgbGFzdEtleVN0cm9rZSA9IF9tWzBdLCBzZXRMYXN0S2V5U3Ryb2tlID0gX21bMV07XG4gICAgdmFyIGlucHV0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dFJlZi5jdXJyZW50OyB9KTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGNoYW5nZSBpbiB2YWx1ZVxuICAgICAqL1xuICAgIHZhciBwcm9jZXNzQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlLCBzZWxlY3Rpb25TdGFydCkge1xuICAgICAgICBzZXREaXJ0eSh0cnVlKTtcbiAgICAgICAgdmFyIF9hID0gcmVwb3NpdGlvbkN1cnNvcih7XG4gICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBsYXN0S2V5U3Ryb2tlOiBsYXN0S2V5U3Ryb2tlLFxuICAgICAgICAgICAgc3RhdGVWYWx1ZTogc3RhdGVWYWx1ZSxcbiAgICAgICAgICAgIGdyb3VwU2VwYXJhdG9yOiBncm91cFNlcGFyYXRvcixcbiAgICAgICAgfSksIG1vZGlmaWVkVmFsdWUgPSBfYS5tb2RpZmllZFZhbHVlLCBjdXJzb3JQb3NpdGlvbiA9IF9hLmN1cnNvclBvc2l0aW9uO1xuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBjbGVhblZhbHVlKF9fYXNzaWduKHsgdmFsdWU6IG1vZGlmaWVkVmFsdWUgfSwgY2xlYW5WYWx1ZU9wdGlvbnMpKTtcbiAgICAgICAgaWYgKHVzZXJNYXhMZW5ndGggJiYgc3RyaW5nVmFsdWUucmVwbGFjZSgvLS9nLCAnJykubGVuZ3RoID4gdXNlck1heExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgfHwgc3RyaW5nVmFsdWUgPT09ICctJyB8fCBzdHJpbmdWYWx1ZSA9PT0gZGVjaW1hbFNlcGFyYXRvcikge1xuICAgICAgICAgICAgb25WYWx1ZUNoYW5nZSAmJiBvblZhbHVlQ2hhbmdlKHVuZGVmaW5lZCwgbmFtZSwgeyBmbG9hdDogbnVsbCwgZm9ybWF0dGVkOiAnJywgdmFsdWU6ICcnIH0pO1xuICAgICAgICAgICAgc2V0U3RhdGVWYWx1ZShzdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICAvLyBBbHdheXMgc2V0cyBjdXJzb3IgYWZ0ZXIgJy0nIG9yIGRlY2ltYWxTZXBhcmF0b3IgaW5wdXRcbiAgICAgICAgICAgIHNldEN1cnNvcigxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyaW5nVmFsdWVXaXRob3V0U2VwYXJhdG9yID0gZGVjaW1hbFNlcGFyYXRvclxuICAgICAgICAgICAgPyBzdHJpbmdWYWx1ZS5yZXBsYWNlKGRlY2ltYWxTZXBhcmF0b3IsICcuJylcbiAgICAgICAgICAgIDogc3RyaW5nVmFsdWU7XG4gICAgICAgIHZhciBudW1iZXJWYWx1ZSA9IHBhcnNlRmxvYXQoc3RyaW5nVmFsdWVXaXRob3V0U2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gZm9ybWF0VmFsdWUoX19hc3NpZ24oeyB2YWx1ZTogc3RyaW5nVmFsdWUgfSwgZm9ybWF0VmFsdWVPcHRpb25zKSk7XG4gICAgICAgIGlmIChjdXJzb3JQb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGN1cnNvciBqdW1waW5nXG4gICAgICAgICAgICB2YXIgbmV3Q3Vyc29yID0gY3Vyc29yUG9zaXRpb24gKyAoZm9ybWF0dGVkVmFsdWUubGVuZ3RoIC0gdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld0N1cnNvciA9IG5ld0N1cnNvciA8PSAwID8gKHByZWZpeCA/IHByZWZpeC5sZW5ndGggOiAwKSA6IG5ld0N1cnNvcjtcbiAgICAgICAgICAgIHNldEN1cnNvcihuZXdDdXJzb3IpO1xuICAgICAgICAgICAgc2V0Q2hhbmdlQ291bnQoY2hhbmdlQ291bnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTdGF0ZVZhbHVlKGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgICAgaWYgKG9uVmFsdWVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB7XG4gICAgICAgICAgICAgICAgZmxvYXQ6IG51bWJlclZhbHVlLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZDogZm9ybWF0dGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0cmluZ1ZhbHVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9uVmFsdWVDaGFuZ2Uoc3RyaW5nVmFsdWUsIG5hbWUsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBjaGFuZ2UgZXZlbnRcbiAgICAgKi9cbiAgICB2YXIgaGFuZGxlT25DaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gZXZlbnQudGFyZ2V0LCB2YWx1ZSA9IF9hLnZhbHVlLCBzZWxlY3Rpb25TdGFydCA9IF9hLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBwcm9jZXNzQ2hhbmdlKHZhbHVlLCBzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgIG9uQ2hhbmdlICYmIG9uQ2hhbmdlKGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBmb2N1cyBldmVudFxuICAgICAqL1xuICAgIHZhciBoYW5kbGVPbkZvY3VzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIG9uRm9jdXMgJiYgb25Gb2N1cyhldmVudCk7XG4gICAgICAgIHJldHVybiBzdGF0ZVZhbHVlID8gc3RhdGVWYWx1ZS5sZW5ndGggOiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGJsdXIgZXZlbnRcbiAgICAgKlxuICAgICAqIEZvcm1hdCB2YWx1ZSBieSBwYWRkaW5nL3RyaW1taW5nIGRlY2ltYWxzIGlmIHJlcXVpcmVkIGJ5XG4gICAgICovXG4gICAgdmFyIGhhbmRsZU9uQmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIHZhciB2YWx1ZU9ubHkgPSBjbGVhblZhbHVlKF9fYXNzaWduKHsgdmFsdWU6IHZhbHVlIH0sIGNsZWFuVmFsdWVPcHRpb25zKSk7XG4gICAgICAgIGlmICh2YWx1ZU9ubHkgPT09ICctJyB8fCB2YWx1ZU9ubHkgPT09IGRlY2ltYWxTZXBhcmF0b3IgfHwgIXZhbHVlT25seSkge1xuICAgICAgICAgICAgc2V0U3RhdGVWYWx1ZSgnJyk7XG4gICAgICAgICAgICBvbkJsdXIgJiYgb25CbHVyKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZml4ZWREZWNpbWFscyA9IGZpeGVkRGVjaW1hbFZhbHVlKHZhbHVlT25seSwgZGVjaW1hbFNlcGFyYXRvciwgZml4ZWREZWNpbWFsTGVuZ3RoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gcGFkVHJpbVZhbHVlKGZpeGVkRGVjaW1hbHMsIGRlY2ltYWxTZXBhcmF0b3IsIGRlY2ltYWxTY2FsZSAhPT0gdW5kZWZpbmVkID8gZGVjaW1hbFNjYWxlIDogZml4ZWREZWNpbWFsTGVuZ3RoKTtcbiAgICAgICAgdmFyIG51bWJlclZhbHVlID0gcGFyc2VGbG9hdChuZXdWYWx1ZS5yZXBsYWNlKGRlY2ltYWxTZXBhcmF0b3IsICcuJykpO1xuICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSBmb3JtYXRWYWx1ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZm9ybWF0VmFsdWVPcHRpb25zKSwgeyB2YWx1ZTogbmV3VmFsdWUgfSkpO1xuICAgICAgICBpZiAob25WYWx1ZUNoYW5nZSAmJiBmb3JtYXRWYWx1ZU9uQmx1cikge1xuICAgICAgICAgICAgb25WYWx1ZUNoYW5nZShuZXdWYWx1ZSwgbmFtZSwge1xuICAgICAgICAgICAgICAgIGZsb2F0OiBudW1iZXJWYWx1ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQ6IGZvcm1hdHRlZFZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFN0YXRlVmFsdWUoZm9ybWF0dGVkVmFsdWUpO1xuICAgICAgICBvbkJsdXIgJiYgb25CbHVyKGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBrZXkgZG93biBldmVudFxuICAgICAqXG4gICAgICogSW5jcmVhc2Ugb3IgZGVjcmVhc2UgdmFsdWUgYnkgc3RlcFxuICAgICAqL1xuICAgIHZhciBoYW5kbGVPbktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IGV2ZW50LmtleTtcbiAgICAgICAgc2V0TGFzdEtleVN0cm9rZShrZXkpO1xuICAgICAgICBpZiAoc3RlcCAmJiAoa2V5ID09PSAnQXJyb3dVcCcgfHwga2V5ID09PSAnQXJyb3dEb3duJykpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzZXRDdXJzb3Ioc3RhdGVWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHBhcnNlRmxvYXQodXNlclZhbHVlICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IFN0cmluZyh1c2VyVmFsdWUpLnJlcGxhY2UoZGVjaW1hbFNlcGFyYXRvciwgJy4nKVxuICAgICAgICAgICAgICAgIDogY2xlYW5WYWx1ZShfX2Fzc2lnbih7IHZhbHVlOiBzdGF0ZVZhbHVlIH0sIGNsZWFuVmFsdWVPcHRpb25zKSkpIHx8IDA7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBrZXkgPT09ICdBcnJvd1VwJyA/IGN1cnJlbnRWYWx1ZSArIHN0ZXAgOiBjdXJyZW50VmFsdWUgLSBzdGVwO1xuICAgICAgICAgICAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkICYmIG5ld1ZhbHVlIDwgTnVtYmVyKG1pbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgbmV3VmFsdWUgPiBOdW1iZXIobWF4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaXhlZExlbmd0aCA9IFN0cmluZyhzdGVwKS5pbmNsdWRlcygnLicpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIoU3RyaW5nKHN0ZXApLnNwbGl0KCcuJylbMV0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcHJvY2Vzc0NoYW5nZShTdHJpbmcoZml4ZWRMZW5ndGggPyBuZXdWYWx1ZS50b0ZpeGVkKGZpeGVkTGVuZ3RoKSA6IG5ld1ZhbHVlKS5yZXBsYWNlKCcuJywgZGVjaW1hbFNlcGFyYXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIG9uS2V5RG93biAmJiBvbktleURvd24oZXZlbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGtleSB1cCBldmVudFxuICAgICAqXG4gICAgICogTW92ZSBjdXJzb3IgaWYgdGhlcmUgaXMgYSBzdWZmaXggdG8gcHJldmVudCB1c2VyIHR5cGluZyBwYXN0IHN1ZmZpeFxuICAgICAqL1xuICAgIHZhciBoYW5kbGVPbktleVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXkgPSBldmVudC5rZXksIHNlbGVjdGlvblN0YXJ0ID0gZXZlbnQuY3VycmVudFRhcmdldC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgaWYgKGtleSAhPT0gJ0Fycm93VXAnICYmIGtleSAhPT0gJ0Fycm93RG93bicgJiYgc3RhdGVWYWx1ZSAhPT0gJy0nKSB7XG4gICAgICAgICAgICB2YXIgc3VmZml4XzEgPSBnZXRTdWZmaXgoc3RhdGVWYWx1ZSwgeyBncm91cFNlcGFyYXRvcjogZ3JvdXBTZXBhcmF0b3IsIGRlY2ltYWxTZXBhcmF0b3I6IGRlY2ltYWxTZXBhcmF0b3IgfSk7XG4gICAgICAgICAgICBpZiAoc3VmZml4XzEgJiYgc2VsZWN0aW9uU3RhcnQgJiYgc2VsZWN0aW9uU3RhcnQgPiBzdGF0ZVZhbHVlLmxlbmd0aCAtIHN1ZmZpeF8xLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0N1cnNvciA9IHN0YXRlVmFsdWUubGVuZ3RoIC0gc3VmZml4XzEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dFJlZi5jdXJyZW50LnNldFNlbGVjdGlvblJhbmdlKG5ld0N1cnNvciwgbmV3Q3Vyc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25LZXlVcCAmJiBvbktleVVwKGV2ZW50KTtcbiAgICB9O1xuICAgIC8vIFVwZGF0ZSBzdGF0ZSBpZiB1c2VyVmFsdWUgY2hhbmdlcyB0byB1bmRlZmluZWRcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodXNlclZhbHVlID09IG51bGwgJiYgZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHNldFN0YXRlVmFsdWUoJycpO1xuICAgICAgICB9XG4gICAgfSwgW2RlZmF1bHRWYWx1ZSwgdXNlclZhbHVlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcHJldmVudCBjdXJzb3IganVtcGluZyBpZiBlZGl0aW5nIHZhbHVlXG4gICAgICAgIGlmIChkaXJ0eSAmJlxuICAgICAgICAgICAgc3RhdGVWYWx1ZSAhPT0gJy0nICYmXG4gICAgICAgICAgICBpbnB1dFJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBpbnB1dFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBpbnB1dFJlZi5jdXJyZW50LnNldFNlbGVjdGlvblJhbmdlKGN1cnNvciwgY3Vyc29yKTtcbiAgICAgICAgfVxuICAgIH0sIFtzdGF0ZVZhbHVlLCBjdXJzb3IsIGlucHV0UmVmLCBkaXJ0eSwgY2hhbmdlQ291bnRdKTtcbiAgICAvKipcbiAgICAgKiBJZiB1c2VyIGhhcyBvbmx5IGVudGVyZWQgXCItXCIgb3IgZGVjaW1hbCBzZXBhcmF0b3IsXG4gICAgICoga2VlcCB0aGUgY2hhciB0byBhbGxvdyB0aGVtIHRvIGVudGVyIG5leHQgdmFsdWVcbiAgICAgKi9cbiAgICB2YXIgZ2V0UmVuZGVyVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh1c2VyVmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgc3RhdGVWYWx1ZSAhPT0gJy0nICYmXG4gICAgICAgICAgICAoIWRlY2ltYWxTZXBhcmF0b3IgfHwgc3RhdGVWYWx1ZSAhPT0gZGVjaW1hbFNlcGFyYXRvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZm9ybWF0VmFsdWVPcHRpb25zKSwgeyBkZWNpbWFsU2NhbGU6IGRpcnR5ID8gdW5kZWZpbmVkIDogZGVjaW1hbFNjYWxlLCB2YWx1ZTogU3RyaW5nKHVzZXJWYWx1ZSkgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZVZhbHVlO1xuICAgIH07XG4gICAgdmFyIGlucHV0UHJvcHMgPSBfX2Fzc2lnbih7IHR5cGU6ICd0ZXh0JywgaW5wdXRNb2RlOiAnZGVjaW1hbCcsIGlkOiBpZCwgbmFtZTogbmFtZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUsIG9uQ2hhbmdlOiBoYW5kbGVPbkNoYW5nZSwgb25CbHVyOiBoYW5kbGVPbkJsdXIsIG9uRm9jdXM6IGhhbmRsZU9uRm9jdXMsIG9uS2V5RG93bjogaGFuZGxlT25LZXlEb3duLCBvbktleVVwOiBoYW5kbGVPbktleVVwLCBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsIGRpc2FibGVkOiBkaXNhYmxlZCwgdmFsdWU6IGdldFJlbmRlclZhbHVlKCksIHJlZjogaW5wdXRSZWYgfSwgcHJvcHMpO1xuICAgIGlmIChjdXN0b21JbnB1dCkge1xuICAgICAgICB2YXIgQ3VzdG9tSW5wdXQgPSBjdXN0b21JbnB1dDtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ3VzdG9tSW5wdXQsIF9fYXNzaWduKHt9LCBpbnB1dFByb3BzKSk7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgX19hc3NpZ24oe30sIGlucHV0UHJvcHMpKTtcbn0pO1xuQ3VycmVuY3lJbnB1dC5kaXNwbGF5TmFtZSA9ICdDdXJyZW5jeUlucHV0JztcblxuZXhwb3J0IHsgY2xlYW5WYWx1ZSwgQ3VycmVuY3lJbnB1dCBhcyBkZWZhdWx0LCBmb3JtYXRWYWx1ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-currency-input-field/dist/index.esm.js\n");

/***/ })

};
;